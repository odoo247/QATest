# -*- coding: utf-8 -*-

from odoo import models, fields, api
from odoo.exceptions import UserError, ValidationError
import logging

_logger = logging.getLogger(__name__)


class QATestSpec(models.Model):
    _name = 'qa.test.spec'
    _description = 'Test Specification'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _order = 'sequence, id'

    name = fields.Char(string='Specification Name', required=True, tracking=True)
    sequence = fields.Integer(string='Sequence', default=10)
    active = fields.Boolean(default=True)
    
    # Classification
    module_id = fields.Many2one('ir.module.module', string='Odoo Module',
                                domain=[('state', '=', 'installed')],
                                help='The Odoo module this spec relates to')
    module_name = fields.Char(string='Module Technical Name', 
                              compute='_compute_module_name', store=True)
    category = fields.Selection([
        ('functional', 'Functional Test'),
        ('integration', 'Integration Test'),
        ('regression', 'Regression Test'),
        ('smoke', 'Smoke Test'),
        ('e2e', 'End-to-End Test'),
    ], string='Test Category', default='functional', required=True)
    priority = fields.Selection([
        ('0', 'Low'),
        ('1', 'Normal'),
        ('2', 'High'),
        ('3', 'Critical'),
    ], string='Priority', default='1')
    
    # Specification Content
    description = fields.Text(string='Description',
                              help='Brief description of what this test covers')
    specification = fields.Text(string='Functional Specification', required=True,
                                help='Write the test specification in plain text. AI will generate tests from this.')
    preconditions = fields.Text(string='Preconditions',
                                help='Any setup required before running the test')
    postconditions = fields.Text(string='Expected Results',
                                 help='Expected state after test completion')
    
    # Module Analysis (Auto-populated)
    analyzed_models = fields.Text(string='Detected Models', readonly=True,
                                  help='Models detected from the Odoo module')
    analyzed_views = fields.Text(string='Detected Views', readonly=True,
                                 help='Views detected from the Odoo module')
    analyzed_fields = fields.Text(string='Detected Fields', readonly=True,
                                  help='Fields detected from the Odoo module')
    analyzed_buttons = fields.Text(string='Detected Buttons', readonly=True,
                                   help='Buttons/actions detected from views')
    analysis_date = fields.Datetime(string='Last Analysis Date', readonly=True)
    
    # Relations
    suite_id = fields.Many2one('qa.test.suite', string='Test Suite',
                               help='Group this spec into a test suite')
    test_case_ids = fields.One2many('qa.test.case', 'spec_id', string='Generated Tests')
    test_case_count = fields.Integer(string='Test Count', compute='_compute_test_case_count')
    
    # Status
    state = fields.Selection([
        ('draft', 'Draft'),
        ('analyzed', 'Analyzed'),
        ('generating', 'Generating'),
        ('generated', 'Tests Generated'),
        ('error', 'Error'),
    ], string='Status', default='draft', tracking=True)
    generation_log = fields.Text(string='Generation Log', readonly=True)
    error_message = fields.Text(string='Error Message', readonly=True)
    
    # Tags
    tag_ids = fields.Many2many('qa.test.tag', string='Tags')
    
    # Audit
    created_by_id = fields.Many2one('res.users', string='Created By',
                                    default=lambda self: self.env.user, readonly=True)
    last_generated_date = fields.Datetime(string='Last Generated', readonly=True)
    last_generated_by_id = fields.Many2one('res.users', string='Generated By', readonly=True)

    @api.depends('module_id')
    def _compute_module_name(self):
        for record in self:
            record.module_name = record.module_id.name if record.module_id else False

    @api.depends('test_case_ids')
    def _compute_test_case_count(self):
        for record in self:
            record.test_case_count = len(record.test_case_ids)

    def action_analyze_module(self):
        """Analyze the selected Odoo module to extract models, views, and fields"""
        self.ensure_one()
        if not self.module_id:
            raise UserError('Please select an Odoo module to analyze.')
        
        try:
            from ..services.code_analyzer import CodeAnalyzer
            analyzer = CodeAnalyzer(self.env)
            result = analyzer.analyze_module(self.module_id.name)
            
            self.write({
                'analyzed_models': result.get('models', ''),
                'analyzed_views': result.get('views', ''),
                'analyzed_fields': result.get('fields', ''),
                'analyzed_buttons': result.get('buttons', ''),
                'analysis_date': fields.Datetime.now(),
                'state': 'analyzed',
            })
            
            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': 'Analysis Complete',
                    'message': f'Module "{self.module_id.name}" analyzed successfully.',
                    'type': 'success',
                    'sticky': False,
                }
            }
        except Exception as e:
            _logger.error(f"Module analysis failed: {str(e)}")
            self.write({
                'state': 'error',
                'error_message': str(e),
            })
            raise UserError(f'Module analysis failed: {str(e)}')

    def action_generate_tests(self):
        """Generate Robot Framework tests from specification using AI"""
        self.ensure_one()
        
        # Open wizard for generation options
        return {
            'name': 'Generate Tests',
            'type': 'ir.actions.act_window',
            'res_model': 'qa.test.generate.wizard',
            'view_mode': 'form',
            'target': 'new',
            'context': {
                'default_spec_ids': [(6, 0, [self.id])],
            }
        }

    def action_generate_tests_direct(self):
        """Generate tests directly without wizard"""
        self.ensure_one()
        self._generate_tests()
        return True

    def _generate_tests(self):
        """Internal method to generate tests"""
        self.write({'state': 'generating', 'error_message': False})
        
        try:
            config = self.env['qa.test.ai.config'].get_active_config()
            from ..services.ai_generator import AIGenerator
            generator = AIGenerator(config)
            
            # Prepare context for AI
            context = {
                'spec_name': self.name,
                'specification': self.specification,
                'preconditions': self.preconditions or '',
                'postconditions': self.postconditions or '',
                'module_name': self.module_name or '',
                'category': self.category,
                'analyzed_models': self.analyzed_models or '',
                'analyzed_views': self.analyzed_views or '',
                'analyzed_fields': self.analyzed_fields or '',
                'analyzed_buttons': self.analyzed_buttons or '',
            }
            
            # Generate tests
            result = generator.generate_tests(context)
            
            if result.get('success'):
                # Create test cases from result
                for test_data in result.get('test_cases', []):
                    self.env['qa.test.case'].create({
                        'spec_id': self.id,
                        'name': test_data.get('name'),
                        'description': test_data.get('description'),
                        'robot_code': test_data.get('robot_code'),
                        'tags': test_data.get('tags', ''),
                        'state': 'ready',
                    })
                
                self.write({
                    'state': 'generated',
                    'generation_log': result.get('log', ''),
                    'last_generated_date': fields.Datetime.now(),
                    'last_generated_by_id': self.env.user.id,
                })
                
                self.message_post(body=f"Generated {len(result.get('test_cases', []))} test cases.")
            else:
                raise Exception(result.get('error', 'Unknown error'))
                
        except Exception as e:
            _logger.error(f"Test generation failed: {str(e)}")
            self.write({
                'state': 'error',
                'error_message': str(e),
            })
            raise UserError(f'Test generation failed: {str(e)}')

    def action_view_tests(self):
        """View generated test cases"""
        self.ensure_one()
        return {
            'name': 'Test Cases',
            'type': 'ir.actions.act_window',
            'res_model': 'qa.test.case',
            'view_mode': 'tree,form',
            'domain': [('spec_id', '=', self.id)],
            'context': {'default_spec_id': self.id},
        }

    def action_reset_to_draft(self):
        """Reset specification to draft state"""
        self.write({
            'state': 'draft',
            'error_message': False,
            'generation_log': False,
        })

    def action_regenerate_tests(self):
        """Delete existing tests and regenerate"""
        self.ensure_one()
        self.test_case_ids.unlink()
        return self.action_generate_tests()

    @api.model
    def create(self, vals):
        record = super().create(vals)
        record.message_post(body="Test specification created.")
        return record

    def write(self, vals):
        result = super().write(vals)
        if 'specification' in vals:
            self.filtered(lambda r: r.state == 'generated').write({'state': 'draft'})
        return result


class QATestTag(models.Model):
    _name = 'qa.test.tag'
    _description = 'Test Tag'

    name = fields.Char(string='Tag Name', required=True)
    color = fields.Integer(string='Color')
    description = fields.Text(string='Description')

    _sql_constraints = [
        ('name_unique', 'UNIQUE(name)', 'Tag name must be unique'),
    ]
